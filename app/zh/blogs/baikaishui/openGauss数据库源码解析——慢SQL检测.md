---
title: 'openGauss数据库源码解析——慢SQL检测'
date: '2021-12-09'
category: 'blog'
tags: ['openGauss安装']
archives: '2021-12'
author: 'baikaishui'
summary: 'openGauss数据库源码解析——慢SQL检测'
times: '20:20'
---

# openGauss 数据库源码解析——慢 SQL 检测

## **慢 SQL 检测的定义：**

基于历史 SQL 语句信息进行模型训练，并用训练好的模型进行 SQL 语句的预测，利用预测结果判断该 SQL 语句是否是潜在的慢 SQL。当发现潜在的慢 SQL 后，开发者便可以进行针对性优化或者风险评估，以防业务上线后发生问题。

## **慢 SQL 检测的功能：**

上线业务预检测：上线一批新业务前，使用 SQL 诊断功能评估此次上线业务的预估执行时长，便于用户参考是否应该修改上线业务。workload 分析：能够对现有 workload 进行分析，将现有 workload 自动分为若干类别，并依次分析此类别 SQL 语句执行代价，以及各个类别之间的相似程度。

## **首先，明确一下慢 SQL 发现的几个不同阶段，及其对应解决的问题。**

阶段 1：对用户输入的一批业务 SQL 语句进行分析，推断 SQL 语句执行时间的快慢，进而可以将评估为慢 SQL 的语句识别出来。

阶段 2：对识别出的潜在慢 SQL 进行根因诊断，判断这些 SQL 语句是因为什么慢，例如比较常见的原因可能是数据量过大、SQL 语句自身过于复杂、容易产生并发的锁冲突、没有创建索引导致全表扫描等等。

阶段 3：对于已经识别出来的慢 SQL 语句的可能问题源，给出针对性的解决方案，譬如可以提示用户进行 SQL 语句的改写、创建索引等。

目前 openGauss 已具备阶段 1 的能力，正在推进阶段 2 能力，同时发布了部分阶段 3 的能力，如索引推荐功能。业内对于上述第一阶段的主要实现方法大部分是通过执行计划进行估计的，第二阶段大多是通过构建故障模式库、通过启发式规则来实现的，有了上述前两个阶段的准备，第三阶段的实现往往是比较独立的。学术界对于第一阶段的研究比较多，第二阶段采用常规的构建故障模式库的方法实现已经能取得比较好的效果了，因此并不是研究的热点，而第三阶段的工作又相对独立，可以单独作为一个领域进行研究。

## **基于执行计划的 DNN 模型：**

<img src='https://oss-emcsprod-public.modb.pro/image/editor/20211206-a0155d62-7c76-44c0-8ca0-644fbcebb6b7.png'>

功能流程：

<img src='https://oss-emcsprod-public.modb.pro/image/editor/20211206-2470d485-1f71-4f9a-b7f9-8df79843f8a8.png'>

该算法是将执行计划中的算子信息输入到深度学习网络中，从而对执行时间进行预测的。对于每个算子，收集左右子树的向量化特征、优化器代价及执行时间，输入与之对应的模型中，预测该算子的向量化特征及执行时间等。上述过程是个自底向上的过程。

## **例如——Join 操作预测流程**

<img src='https://oss-emcsprod-public.modb.pro/image/editor/20211206-763a81c7-b907-412d-a043-cc67e1c6d3d0.png'>

该流程图显示了一个 join 操作的预测流程，其左右子树均为 Scan 算子，将两个 Scan 算子通过对应的模型预测出的向量化特征、执行时间，以及该 join 算子的优化器评估代价作为入参，输出 join 算子模型得到该操作的向量化特征及预测出的执行时间。

上述技术的缺点。  
（1） 需要通过已预测算子不断修正模型，预测过程会较慢。  
（2） 对环境变化感知差，如数据库参数变化会使得原模型几乎完全失效。  
（3） 预测过程依赖待测语句的执行计划，加重了数据库的负荷，对于 OLTP 场景格外不适用。

## 基于执行计划的 MART（multiple additive regression trees，多重累加回归树）模型，主要包含离线训练模块和在线预测模块。他们的功能如下所示。

<img src='https://oss-emcsprod-public.modb.pro/image/editor/20211206-5956992c-432e-4853-97c8-57f71fca288b.png'>

**离线训练阶段：**针对数据库每种类型的算子（如 Table Scan，Merge Join，Sort…），分别训练其对应的模型，用于估算此算子的开销。此外，使用单独的训练阶段，可为不同的算子选择适当的缩放函数。最后，形成带缩放函数的不同的回归树模型。

**在线预测阶段：**计算出执行计划中所有算子的特征值。然后，使用特征值为算子选择合适的模型，并使用它来估算执行时间。

## **功能流程：**

<img src='https://oss-emcsprod-public.modb.pro/image/editor/20211206-973086cb-e4cb-40f2-abc2-98233bb73447.png'>

## 基于执行计划 MART 模型技术调优技术的缺点。

1.泛用性较差，强依赖训练好的算子模型，遇到例如用户自定义函数的未知语句时，预测效果会较差。

2.缩放函数依赖于先验结果，对于超出范围的特征值效果无法保证。

3.预测过程依赖待测语句的执行计划，加重了数据库的负荷，很难推广到 OLTP 场景中。

## **慢 SQL 检测采取的策略：**

<img src='https://oss-emcsprod-public.modb.pro/image/editor/20211206-56ce6c57-4130-402a-bf1c-18d01f846389.png'>

## **基于 SQL 模板化的流程**

<img src='https://oss-emcsprod-public.modb.pro/image/editor/20211206-8eb7d06c-0348-4883-8a9f-e3ee76b49347.png'>

## 基于 SQL 模板化的流程类似于基于执行计划 MART 模型技术调优技术，他的具体流程如下：

1.获取 SQL 流水数据。

2.检测本地是否存在对应实例的历史模板信息，如果存在，则加载该模板信息，如果不存在，则对该模板进行初始化。

3.基于 SQL 数据，提取 SQL 的粗粒度模板信息。粗粒度模板表示将 SQL 中表名、列名和其他敏感信息去除之后的 SQL 语句模板，该模板只保留最基本的 SQL 语句骨架。

4.基于 SQL 数据，提取 SQL 细粒度的模板信息。细粒度模板表示在粗粒度模板信息的基础上保留表名、列名等关键信息的 SQL 语句模板。细粒度模板相对粗粒度模板保留了更多 SQL 语句的信息。

5.执行训练过程时，首先构造 SQL 语句的基于粗粒度模板和细粒度模板信息，例如粗粒度模板 ID、执行平均时间、细模板执行时间序列、执行平均时间和基于滑动窗口计算出的平均执行时间等。最后将上述模板信息进行储存。

6.执行预测过程时，首先导入对应实例的模板信息，如果不存在该模板信息，则直接报错退出；否则继续检测是否存在该 SQL 语句的粗粒度模板信息，如果不存在，则基于模板相似度计算方法在所有粗粒度模板里面寻找最相似的 N 条模板，之后基于 KNN（K 近邻）算法预测出执行时间；如果存在粗粒度模板，则接着检测是否存在近似的细粒度模板，如果不存在，则基于模板相似度计算方法在所有细粒度模板里面寻找最相似的 N 条模板，之后基于 KNN 预测出执行时间；如果存在匹配的细粒度模板，则基于当前模板数据，直接返回对应的执行时间。

## **实现代码：**

<img src='https://oss-emcsprod-public.modb.pro/image/editor/20211206-6121c222-f7c6-4f31-9fca-cadded23a147.png'>

<img src='https://oss-emcsprod-public.modb.pro/image/editor/20211206-7ee30873-03d5-421c-bbb7-51860ef202f7.png'>

## **基于深度学习的执行流程**

<img src='https://oss-emcsprod-public.modb.pro/image/editor/20211206-aa63931a-ff58-49a6-a88c-2f38a977c554.png'>

1.获取 SQL 流水。

2.在训练过程中，首先判断是否存在历史模型，如果存在，则导入模型进行增量训练；如果不存在历史模型，则首先利用 word2vector 算法对 SQL 语句进行向量化，即图 8-11 中的 SQL embeding 过程。而后创建深度学习模型，将该 SQL 语句向量化的结果作为输入特征。基于训练数据进行训练，并将模型保存到本地。值得一提的是，该深度学习模型的最后一个全连接层网络的输出结果作为该 SQL 语句的特征向量。

3.在预测过程中，首先判断是否存在模型，如果模型不存在，则直接报错退出；如果存在模型，则导入模型，并利用 word2vector 算法将待预测的 SQL 语句进行向量化，并将该向量输入到深度学习网络中，获取该神经网络的最后一个全连接层的输出结果，即为该 SQL 语句的特征向量。最后，利用余弦相似度在样本数据集中进行寻找，找到相似度最高的 SQL 语句，将该结果返回即为该待预测 SQL 语句的预估执行时间。当然，如果是基于最新 SQL 语句执行时间数据集训练出的深度学习模型，则模型的回归预测结果也可以作为预估执行时间。

## **实现代码：**

<img src='https://oss-emcsprod-public.modb.pro/image/editor/20211206-8cdb6977-81bd-4e4a-b840-99da3d3facdf.png'>

<img src='https://oss-emcsprod-public.modb.pro/image/editor/20211206-a7424067-b725-41fe-a0e1-92d7d3ef3e1b.png'>

## **总体流程代码解析**

<img src='https://oss-emcsprod-public.modb.pro/image/editor/20211206-42feeab5-e4de-41e6-a704-fbec10987aff.png'>

参考文章：[Gauss 松鼠会源码解析](https://blog.csdn.net/GaussDB/article/details/119989581?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163876954016780269849143%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=163876954016780269849143&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-3-119989581.pc_v2_rank_blog_default&utm_term=%E6%BA%90%E7%A0%81%E6%A3%80%E6%B5%8B&spm=1018.2226.3001.4450)
